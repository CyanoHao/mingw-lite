diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index 946fefd9e44..342967c7c6e 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -108,21 +108,37 @@ fs::absolute(const path& p, error_code& ec)
       s.remove_prefix(std::min(s.length(), pos) - 1);
     }
 
-  uint32_t len = 1024;
-  wstring buf;
-  do
-    {
-      buf.__resize_and_overwrite(len, [&s, &len](wchar_t* p, unsigned n) {
-	len = GetFullPathNameW(s.data(), n, p, nullptr);
-	return len > n ? 0 : len;
-      });
-    }
-  while (len > buf.size());
+  if (posix::is_nt()) {
+    uint32_t len = 1024;
+    wstring buf;
+    do
+      {
+	buf.__resize_and_overwrite(len, [&s, &len](wchar_t* p, unsigned n) {
+	  len = GetFullPathNameW(s.data(), n, p, nullptr);
+	  return len > n ? 0 : len;
+	});
+      }
+    while (len > buf.size());
 
-  if (len == 0)
-    ec = __last_system_error();
-  else
-    ret = std::move(buf);
+    if (len == 0)
+      ec = __last_system_error();
+    else
+      ret = std::move(buf);
+  } else {
+    string as = posix::narrow(s);
+    uint32_t alen = 1024;
+    string abuf;
+    do {
+      abuf.__resize_and_overwrite(alen, [&as, &alen](char* p, unsigned n) {
+	alen = GetFullPathNameA(as.data(), n, p, nullptr);
+	return alen > n ? 0 : alen;
+      });
+    } while (alen > abuf.size());
+    if (alen == 0)
+      ec = __last_system_error();
+    else
+      ret = posix::widen(abuf);
+  }
 #else
   ret = current_path(ec);
   ret /= p;
@@ -687,10 +703,16 @@ fs::create_hard_link(const path& to, const path& new_hard_link,
   else
     ec.clear();
 #elif defined _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  if (CreateHardLinkW(new_hard_link.c_str(), to.c_str(), NULL))
-    ec.clear();
-  else
-    ec = __last_system_error();
+  static auto pCreateHardLinkW = (decltype (&CreateHardLinkW))GetProcAddress(
+    GetModuleHandleA("kernel32.dll"), "CreateHardLinkW");
+  if (pCreateHardLinkW) {  // Windows 2000
+    if (pCreateHardLinkW(new_hard_link.c_str(), to.c_str(), NULL))
+      ec.clear();
+    else
+      ec = __last_system_error();
+  } else  // Windows NT 4.0, Windows 9x
+    // TODO: implement on NT 4.0 with `NtSetInformationFile`
+    ec = std::make_error_code(std::errc::function_not_supported);
 #else
   ec = std::make_error_code(std::errc::function_not_supported);
 #endif
@@ -830,9 +852,14 @@ namespace
   {
     explicit
     auto_win_file_handle(const wchar_t* p, std::error_code& ec) noexcept
-    : handle(CreateFileW(p, 0,
-			 FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
-			 0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)),
+    : handle(posix::is_nt() 
+	     ? CreateFileW(p, 0,
+			   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
+			   0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)
+	     : CreateFileA(posix::narrow(p).c_str(), 0,
+			   // FILE_SHARE_DELETE is not supported on Windows 9x
+			   FILE_SHARE_READ | FILE_SHARE_WRITE,
+			   0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)),
       ec(ec)
     {
       if (handle == INVALID_HANDLE_VALUE)
@@ -1299,8 +1326,13 @@ fs::remove(const path& p, error_code& ec) noexcept
   auto st = symlink_status(p, ec);
   if (exists(st))
     {
-      if ((is_directory(p, ec) && RemoveDirectoryW(p.c_str()))
-	  || DeleteFileW(p.c_str()))
+      if (is_directory(p, ec)
+	  && (posix::is_nt()
+	      ? RemoveDirectoryW(p.c_str())
+	      : RemoveDirectoryA(posix::narrow(p.native()).c_str()))
+	  || (posix::is_nt()
+	      ? DeleteFileW(p.c_str())
+	      : DeleteFileA(posix::narrow(p.native()).c_str())))
 	{
 	  ec.clear();
 	  return true;
diff --git a/libstdc++-v3/src/filesystem/dir-common.h b/libstdc++-v3/src/filesystem/dir-common.h
index 95eaf98ed08..033341d76a0 100644
--- a/libstdc++-v3/src/filesystem/dir-common.h
+++ b/libstdc++-v3/src/filesystem/dir-common.h
@@ -30,6 +30,9 @@
 #include <errno.h>
 #if _GLIBCXX_FILESYSTEM_IS_WINDOWS
 #include <wchar.h>  // wcscmp
+#define WIN32_LEAN_AND_MEAN
+#define NOMINMAX
+#include <windows.h>
 #endif
 #ifdef _GLIBCXX_HAVE_DIRENT_H
 # ifdef _GLIBCXX_HAVE_SYS_TYPES_H
@@ -50,13 +53,179 @@ namespace filesystem
 namespace __gnu_posix
 {
 #if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+namespace
+{
+  inline bool is_nt()
+  {
+    static bool result = ({
+      OSVERSIONINFOA osvi = {sizeof (OSVERSIONINFOA)};
+      GetVersionExA(&osvi);
+      osvi.dwPlatformId >= VER_PLATFORM_WIN32_NT;
+    });
+    return result;
+  }
+
+  inline string narrow(wstring_view wpath)
+  {
+    int alen = WideCharToMultiByte(CP_ACP, 0, wpath.data(), wpath.length(),
+				   nullptr, 0, nullptr, nullptr);
+    if (alen == 0)
+      return {};
+    string apath(alen, 0);
+    WideCharToMultiByte(CP_ACP, 0, wpath.data(), wpath.length(),
+			apath.data(), alen, nullptr, nullptr);
+    return apath;
+  }
+
+  inline string narrow(const wchar_t* wpath)
+  {
+    int wlen = wcslen(wpath);
+    return narrow(wstring_view{wpath, wlen});
+  }
+
+  inline string narrow_trunc(const wchar_t* wpath)
+  {
+    string apath = narrow(wpath);
+    if (apath.length() > MAX_PATH - 1)
+      apath.resize(MAX_PATH - 1);
+    return apath;
+  }
+
+  inline wstring widen(string_view apath)
+  {
+    int wlen = MultiByteToWideChar(CP_ACP, 0, apath.data(), apath.length(),
+				   nullptr, 0);
+    if (wlen == 0)
+      return {};
+    wstring wpath(wlen, 0);
+    MultiByteToWideChar(CP_ACP, 0, apath.data(), apath.length(),
+			wpath.data(), wlen);
+    return wpath;
+  }
+
+  inline wstring widen(const char* apath)
+  {
+    int alen = strlen(apath);
+    return widen(string_view{apath, alen});
+  }
+
+  inline wstring widen_trunc(const char* apath)
+  {
+    wstring wpath = widen(apath);
+    if (wpath.length() > MAX_PATH - 1)
+      wpath.resize(MAX_PATH - 1);
+    return wpath;
+  }
+
+  inline void finddata_atow(_wfinddata_t* wdta, const _finddata_t* adta)
+  {
+    wdta->attrib = adta->attrib;
+    wdta->time_create = adta->time_create;
+    wdta->time_access = adta->time_access;
+    wdta->time_write = adta->time_write;
+    wdta->size = adta->size;
+    wstring wname = widen_trunc(adta->name);
+    memcpy(wdta->name, wname.c_str(), (wname.size() + 1) * sizeof (wchar_t));
+  }
+
+  inline void dirent_atow(_wdirent* wdir, const dirent* adir)
+  {
+    wdir->d_ino = 0;  // always zero
+    wdir->d_reclen = 0;  // always zero
+    wstring wname = widen_trunc(adir->d_name);
+    wdir->d_namlen = wname.size();
+    memcpy(wdir->d_name, wname.c_str(), (wname.size() + 1) * sizeof (wchar_t));
+  }
+
+  inline _WDIR* dir_atow(const DIR* adir)
+  {
+    wstring wname = widen(adir->dd_name);
+    _WDIR* wdir = (_WDIR*)malloc(sizeof (_WDIR) + wname.size() * sizeof (wchar_t));
+    finddata_atow(&wdir->dd_dta, &adir->dd_dta);
+    dirent_atow(&wdir->dd_dir, &adir->dd_dir);
+    wdir->dd_handle = adir->dd_handle;
+    wdir->dd_stat = adir->dd_stat;
+    memcpy(wdir->dd_name, wname.c_str(), (wname.size() + 1) * sizeof (wchar_t));
+    return wdir;
+  }
+
+  inline void finddata_wtoa(_finddata_t* adta, const _wfinddata_t* wdta)
+  {
+    adta->attrib = wdta->attrib;
+    adta->time_create = wdta->time_create;
+    adta->time_access = wdta->time_access;
+    adta->time_write = wdta->time_write;
+    adta->size = wdta->size;
+    string aname = narrow_trunc(wdta->name);
+    memcpy(adta->name, aname.c_str(), aname.size() + 1);
+  }
+
+  inline void dirent_wtoa(dirent* adir, const _wdirent* wdir)
+  {
+    adir->d_ino = 0;  // always zero
+    adir->d_reclen = 0;  // always zero
+    string aname = narrow_trunc(wdir->d_name);
+    adir->d_namlen = aname.size();
+    memcpy(adir->d_name, aname.c_str(), aname.size() + 1);
+  }
+
+  inline DIR* dir_wtoa(const _WDIR* wdir)
+  {
+    string aname = narrow(wdir->dd_name);
+    DIR* adir = (DIR*)malloc(sizeof (DIR) + aname.size());  // undocumented
+    finddata_wtoa(&adir->dd_dta, &wdir->dd_dta);
+    dirent_wtoa(&adir->dd_dir, &wdir->dd_dir);
+    adir->dd_handle = wdir->dd_handle;
+    adir->dd_stat = wdir->dd_stat;
+    memcpy(adir->dd_name, aname.c_str(), aname.size() + 1);
+    return adir;
+  }
+}
+
 // Adapt the Windows _wxxx functions to look like POSIX xxx, but for wchar_t*.
 using char_type = wchar_t;
 using DIR = ::_WDIR;
 using dirent = _wdirent;
-inline DIR* opendir(const wchar_t* path) { return ::_wopendir(path); }
-inline dirent* readdir(DIR* dir) { return ::_wreaddir(dir); }
-inline int closedir(DIR* dir) { return ::_wclosedir(dir); }
+
+inline DIR* opendir(const wchar_t* path)
+{
+  if (is_nt())
+    return ::_wopendir(path);
+
+  ::DIR *adir = ::opendir(narrow(path).c_str());
+  if (adir == nullptr)
+    return nullptr;
+  ::_WDIR *wdir = dir_atow(adir);
+  free(adir);  // undocumented
+  return wdir;
+}
+
+inline dirent* readdir(DIR* dir)
+{
+  if (is_nt())
+    return ::_wreaddir(dir);
+
+  ::DIR* adir = dir_wtoa(dir);
+  ::dirent* adirp = ::readdir(adir);
+  finddata_atow(&dir->dd_dta, &adir->dd_dta);
+  if (adirp)
+    dirent_atow(&dir->dd_dir, adirp);
+  dir->dd_handle = adir->dd_handle;
+  dir->dd_stat = adir->dd_stat;
+  free(adir);
+  return adirp ? &dir->dd_dir : nullptr;
+}
+
+inline int closedir(DIR* dir)
+{
+  if (is_nt())
+    return ::_wclosedir(dir);
+
+  ::DIR* adir = dir_wtoa(dir);
+  int ret = ::closedir(adir);
+  free(dir);
+  return ret;
+}
 #elif defined _GLIBCXX_HAVE_DIRENT_H
 using char_type = char;
 using DIR = ::DIR;
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 1be8d754d6f..42e824ea8d6 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -44,6 +44,11 @@
 
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
 # include <wchar.h>
+# include <io.h>
+# include <direct.h>
+# define WIN32_LEAN_AND_MEAN
+# define NOMINMAX
+# include <windows.h>
 #endif
 
 #ifdef NEED_DO_COPY_FILE
@@ -108,12 +113,68 @@ namespace filesystem
 namespace __gnu_posix
 {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+namespace {
+  inline bool is_nt()
+  {
+    static bool result = ({
+      OSVERSIONINFOA osvi = {sizeof (OSVERSIONINFOA)};
+      GetVersionExA(&osvi);
+      osvi.dwPlatformId >= VER_PLATFORM_WIN32_NT;
+    });
+    return result;
+  }
+
+  inline string narrow(wstring_view wpath)
+  {
+    int alen = WideCharToMultiByte(CP_ACP, 0, wpath.data(), wpath.length(),
+				   nullptr, 0, nullptr, nullptr);
+    if (alen == 0)
+      return {};
+    string apath(alen, 0);
+    WideCharToMultiByte(CP_ACP, 0, wpath.data(), wpath.length(),
+			apath.data(), alen, nullptr, nullptr);
+    return apath;
+  }
+
+  inline string narrow(const wchar_t* wpath)
+  {
+    int wlen = wcslen(wpath);
+    return narrow(wstring_view{wpath, wlen});
+  }
+
+  inline wstring widen(string_view apath)
+  {
+    int wlen = MultiByteToWideChar(CP_ACP, 0, apath.data(), apath.length(),
+				   nullptr, 0);
+    if (wlen == 0)
+      return {};
+    wstring wpath(wlen, 0);
+    MultiByteToWideChar(CP_ACP, 0, apath.data(), apath.length(),
+			wpath.data(), wlen);
+    return wpath;
+  }
+
+  inline wstring widen(const char* apath)
+  {
+    int alen = strlen(apath);
+    return widen(string_view{apath, alen});
+  }
+}
+
 // Adapt the Windows _wxxx functions to look like POSIX xxx, but for wchar_t*.
   inline int open(const wchar_t* path, int flags)
-  { return ::_wopen(path, flags); }
+  {
+    if (is_nt())
+      return ::_wopen(path, flags);
+    return ::_open(narrow(path).c_str(), flags);
+  }
 
   inline int open(const wchar_t* path, int flags, int mode)
-  { return ::_wopen(path, flags, mode); }
+  {
+    if (is_nt())
+      return ::_wopen(path, flags, mode);
+    return ::_open(narrow(path).c_str(), flags, mode);
+  }
 
   inline int close(int fd)
   { return ::_close(fd); }
@@ -121,7 +182,39 @@ namespace __gnu_posix
   using stat_type = struct ::__stat64;
 
   inline int stat(const wchar_t* path, stat_type* buffer)
-  { return ::_wstat64(path, buffer); }
+  {
+#ifdef _UCRT
+    return ::_wstat64(path, buffer);
+#else
+    static auto p_wstat64 = (decltype (&::_wstat64))GetProcAddress(
+      GetModuleHandleA("msvcrt.dll"), "_wstat64");
+    if (p_wstat64)  // Windows 2000
+      return p_wstat64(path, buffer);
+
+    struct _stat32i64 buffer32;
+    int ret;
+    if (is_nt())  // Windows NT 4.0
+      ret = ::_wstat32i64(path, &buffer32);
+    else  // Windows 9x
+      ret = ::_stat32i64(narrow(path).c_str(), &buffer32);
+    if (ret == -1) {
+      *buffer = {};
+      return -1;
+    }
+    buffer->st_dev = buffer32.st_dev;
+    buffer->st_ino = buffer32.st_ino;
+    buffer->st_mode = buffer32.st_mode;
+    buffer->st_nlink = buffer32.st_nlink;
+    buffer->st_uid = buffer32.st_uid;
+    buffer->st_gid = buffer32.st_gid;
+    buffer->st_rdev = buffer32.st_rdev;
+    buffer->st_size = buffer32.st_size;
+    buffer->st_atime = buffer32.st_atime;
+    buffer->st_mtime = buffer32.st_mtime;
+    buffer->st_ctime = buffer32.st_ctime;
+    return ret;
+#endif
+  }
 
   inline int lstat(const wchar_t* path, stat_type* buffer)
   {
@@ -132,33 +225,85 @@ namespace __gnu_posix
   using ::mode_t;
 
   inline int chmod(const wchar_t* path, mode_t mode)
-  { return ::_wchmod(path, mode); }
+  {
+    if (is_nt())
+      return ::_wchmod(path, mode);
+    return ::_chmod(narrow(path).c_str(), mode);
+  }
 #define _GLIBCXX_USE_CHMOD 1
 
   inline int mkdir(const wchar_t* path, mode_t)
-  { return ::_wmkdir(path); }
+  {
+    if (is_nt())
+      return ::_wmkdir(path);
+    return ::_mkdir(narrow(path).c_str());
+  }
 #define _GLIBCXX_USE_MKDIR 1
 
   inline wchar_t* getcwd(wchar_t* buf, size_t size)
-  { return ::_wgetcwd(buf, size > (size_t)INT_MAX ? INT_MAX : (int)size); }
+  {
+    if (is_nt())
+      return ::_wgetcwd(buf, size > (size_t)INT_MAX ? INT_MAX : (int)size);
+    char *abuf = _getcwd(nullptr, 0);
+    if (abuf == nullptr)
+      return nullptr;
+    wstring wres = widen(abuf);
+    free(abuf);
+    if (buf) {
+      if (wres.length() > size - 1) {
+	_set_errno(ERANGE);
+	return nullptr;
+      }
+      memcpy(buf, wres.data(), (wres.length() + 1) * sizeof (wchar_t));
+      return buf;
+    } else {
+      size_t buflen = wres.size() + 1;
+      if (buflen < size)
+	buflen = size;
+      buf = (wchar_t*)malloc(buflen * sizeof (wchar_t));
+      memcpy(buf, wres.data(), (wres.length() + 1) * sizeof (wchar_t));
+      return buf;
+    }
+  }
 #define _GLIBCXX_USE_GETCWD 1
 
   inline int chdir(const wchar_t* path)
-  { return ::_wchdir(path); }
+  {
+    if (is_nt())
+      return ::_wchdir(path);
+    return ::_chdir(narrow(path).c_str());
+  }
 #define _GLIBCXX_USE_CHDIR 1
 
 #if !_GLIBCXX_USE_UTIMENSAT && _GLIBCXX_HAVE_UTIME_H
   using utimbuf = _utimbuf;
 
   inline int utime(const wchar_t* path, utimbuf* times)
-  { return ::_wutime(path, times); }
+  {
+    if (is_nt())
+      return ::_wutime(path, times);
+    return ::_utime(narrow(path).c_str(), times);
+  }
 #endif
 
   inline int rename(const wchar_t* oldname, const wchar_t* newname)
   {
-    if (MoveFileExW(oldname, newname,
-		    MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
-      return 0;
+    if (is_nt()) {
+      if (MoveFileExW(oldname, newname,
+		      MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))
+	return 0;
+    } else {
+      // MoveFileExA is a stub on Windows 9x
+      string aold = narrow(oldname);
+      string anew = narrow(newname);
+      if (MoveFileA(aold.c_str(), anew.c_str()))
+	return 0;
+      if (CopyFileA(aold.c_str(), anew.c_str(), false)) {
+	SetLastError(NO_ERROR);
+	DeleteFileA(aold.c_str());
+	return 0;
+      }
+    }
     if (GetLastError() == ERROR_ACCESS_DENIED)
       errno = EACCES;
     else
@@ -169,7 +314,11 @@ namespace __gnu_posix
   using off_t = _off64_t;
   inline int truncate(const wchar_t* path, _off64_t length)
   {
-    const int fd = ::_wopen(path, _O_BINARY|_O_RDWR);
+    int fd = -1;
+    if (is_nt())
+      fd = ::_wopen(path, _O_BINARY|_O_RDWR);
+    else
+      fd = ::_open(narrow(path).c_str(), O_RDWR);
     if (fd == -1)
       return fd;
     const int ret = ::ftruncate64(fd, length);
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index c430f58c47a..4b53c80b564 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -612,10 +612,16 @@ fs::create_hard_link(const path& to, const path& new_hard_link,
   else
     ec.clear();
 #elif defined _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  if (CreateHardLinkW(new_hard_link.c_str(), to.c_str(), NULL))
-    ec.clear();
-  else
-    ec = __last_system_error();
+  static auto pCreateHardLinkW = (decltype (&CreateHardLinkW))GetProcAddress(
+    GetModuleHandleA("kernel32.dll"), "CreateHardLinkW");
+  if (pCreateHardLinkW) {  // Windows 2000
+    if (pCreateHardLinkW(new_hard_link.c_str(), to.c_str(), NULL))
+      ec.clear();
+    else
+      ec = __last_system_error();
+  } else  // Windows NT 4.0, Windows 9x
+    // TODO: implement on NT 4.0 with `NtSetInformationFile`
+    ec = std::make_error_code(std::errc::function_not_supported);
 #else
   ec = std::make_error_code(std::errc::function_not_supported);
 #endif
@@ -1084,8 +1090,13 @@ fs::remove(const path& p, error_code& ec) noexcept
   auto st = symlink_status(p, ec);
   if (exists(st))
     {
-      if ((is_directory(p, ec) && RemoveDirectoryW(p.c_str()))
-	  || DeleteFileW(p.c_str()))
+      if (is_directory(p, ec)
+	  && (posix::is_nt()
+	      ? RemoveDirectoryW(p.c_str())
+	      : RemoveDirectoryA(posix::narrow(p.native()).c_str()))
+	  || (posix::is_nt()
+	      ? DeleteFileW(p.c_str())
+	      : DeleteFileA(posix::narrow(p.native()).c_str())))
 	{
 	  ec.clear();
 	  return true;
